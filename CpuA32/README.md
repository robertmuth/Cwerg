# A32 (aka ARM32) Encoder/Decoder

This directory contains code for encoding and decoding  A32 instructions.

We only support the regular 32 bit ISA.
Neither Thumb nor Thumb-2 are supported.

The implementation is far more complete than what is needed by [../CodeGenA32]
and might be useful by itself.

## Concepts and API

An instruction consists of two parts:
1. a template describing its format, aka `Opcode`,
   which breaks down the instruction into a list of `Operands`.  
2. a list of integers, one for each `Operand` in the `Opcode`.

A list of all opcodes and their operands can be obtained by running
```
./opcode_tab.py 
```

To look up  the concrete decomposition of an instruction word run
```
 ./disassembler.py eefdbbc0
```
which will print 
```
eefdbbc0 vcvt.s32.f64 s23, d0      # assembler notation (implicit `al` predicate not shown)
OPCODE vcvt.s32.f64                # opcode name 
    PRED_28_31          al (14)    # 1. operand name:PRED_28_31     symbolized_val:al  val:14 
    SREG_12_15_22       s23 (23)   # 2. operand name:SREG_12_15_22  symbolized_val:s23 val:23 
    DREG_0_3_5          d0 (0)     # 3. operand name:DREG_0_3_5     symbolized_val:d0  val:0
```

There are helpers for looking up the `Opcode` of a 32 bit instruction 
word, `Opcode.FindOpcode`, and extracting the `Operand` values,
`Opcode.DisassembleOperands`.

Conversely, starting with and `Opcode` and list of `Operand` values
an instruction word can be obtained via `Opcode.AssembleOperands`

An `Opocode` can also be looked up by its name in the dictionary
`Opcode.names_to_opcode`. Note, the name may have two components a basename and possibly 
a variant suffix separated by an underscore:
* `add_regreg` (src2 is reg shifted by another reg)
* `add_regimm` (src2 is reg shifted by immediate)
* `add_imm` (src2 is immediate), 

We re-use the "official" instruction names as base names as much as
possible. 
The variant component is necessary for disambiguation since the
instruction names are heavily overloaded.
The different addressing modes are reflected as variants as well.

 
### Operands

An `Operand` represents:
* the predicate
* a register
* an immediate value
* a register mask
* a shift direction
* etc.

The order of the `Operands` roughly corresponds to the order in the
assembler notation with the following exceptions:
* the predicate is always explicit and the first operand. "al" represents the always
  predicate.
* written registers precede read registers. This affects (v)str
  instructions where the "storee" is moved to the end, and (v)ldm instructions where the register masks is moved to the front.
* the register-list for ldm and stm is expressed as a 16bit integer immediate
* register ranges for vldm and vstm are expressed as a start-register
  followed by an immediate count 
* the lr register in the bl instruction is made explicit
* store and load instruction do not use square brackets, exclamation marks, minus signs
  to indictae the various addressing modes as this is already encoded in the opcode variant
 
 
#### Examples

Standard Notation

    ```
    add r0 r1 r2 asr #3
    ldrb lr, [ip, r3, lsl #1]
    ldrsheq r6, [r4,#-26]
    bl exit
    ```
    
Our Notation
    
    ```
    add_regimm al r0 r1 asr asr 3
    ldrb_reg_add al lr ip r3 lsl 1
    ldrsheq eq, r6, r4, 26
    bl al lr exit
    ```  

Note:
* the predicate is the first operand 
* some `Operands` are implicit and do not correspond to any bits in the
   instruction, e.g. the `bl` instruction implicitly writes register `lr`. 
* the instruction variant is separated with a "_"
* operands are separated by white space NOT commas.  
   

TODO: mention "opcode classes" which are flags attached to opcode
      to quickly answer queries like: is this a store?

## Implementation

The authoritative version of the encoder/decoder is written in Python 3.8
using a table driven approach.

There is a C++ 17 version of the code which is mostly generated from the
Python code. It is mostly a proof of concept and not suitable
for adversarial environments. When the Python code was changed the C++ code 
can be updated like so:

```shell script
make opcode_gen.cc opcode_gen.h
```


Other language ports are encouraged to mimic the approach of generating
code from the Python tables.

## Testing

Run
```shell script
make test
```
before any commit.

## Use as a JIT

To materialize an Instruction for JITing you need to first identify the
proper Opcode and then populate the Operands for each Field.

`arm_table.py` has a query feature which may be helpful here, e.g.
`./arm_table.py mov` will show information for all opcodes with name `mov`
including operand fields and bit ranges.

`jit_example.c` gives an example for generating one specific instruction.


## Opcode coverage

The Opcodes covered by the encoder/decoder are what one would expect to 
see a C compiler emit i.e. basic integer and floating point instructions.
The file `arm_test.dis` which was generated by `objdump -d` has examples
for most currently supported Opcodes.
Missing instructions will be support as needed.

There are no plans to support T32 (aka thumb) instructions which are
a lot more messy.

## Cross Testing  with QEMU

see [../TestQemu/README.md](../TestQemu/README.md)
  
## References

ISA

* arm.com https://static.docs.arm.com/ddi0406/c/DDI0406C_C_arm_architecture_reference_manual.pdf
* asmdb https://github.com/asmjit/asmdb/blob/master/armdata.js
* asmgrid https://asmjit.com/asmgrid/
* PeachPy https://github.com/Maratyszcza/PeachPy
* https://godbolt.org/ check target code generated by various compiler* s 
* online emulator https://cpulator.01xz.net/
* online instruction decoder http://armconverter.com/
* crc32 instruction CRC32C https://developer.arm.com/docs/ddi0597/f/base-instructions-alphabetic-order/crc32c-crc32c#a1

Linking

* relocs https://developer.arm.com/docs/100067/0610/armclang-integrated-assembler-directives/assembly-expressions

OS

* https://chromium.googlesource.com/chromiumos/docs/+/master/constants/syscalls.md
* linux sycall http://man7.org/linux/man-pages/man2/syscall.2.html

