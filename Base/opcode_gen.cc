/* NOTE: this file is PARTIALLY autogenerated via: ./opcode_tab.py gen_c */

#include "Base/opcode_gen.h"
#include "Util/assert.h"

#include <cstring>

namespace cwerg::base {

struct StringKind {
    const char* name;
    uint8_t kind;
};

/* @AUTOGEN-START@ */

const char* const OPC_GENUS_ToStringMap[] = {
    "INVALID", // 0
    "BASE", // 1
    "TBD", // 2
};
const char* EnumToString(OPC_GENUS x) { return OPC_GENUS_ToStringMap[unsigned(x)]; }


const struct StringKind OPC_GENUSFromStringMap[] = {
    {"BASE", 1},
    {"INVALID", 0},
    {"TBD", 2},
    {"ZZZ", 0},
};

const uint8_t OPC_GENUSJumper[128] = {
 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 0, 255, 255, 255, 255, 255, 255, 1, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 2, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,};

const char* const FUN_KIND_ToStringMap[] = {
    "INVALID", // 0
    "BUILTIN", // 1
    "EXTERN", // 2
    "NORMAL", // 3
    "SIGNATURE", // 4
};
const char* EnumToString(FUN_KIND x) { return FUN_KIND_ToStringMap[unsigned(x)]; }


const struct StringKind FUN_KINDFromStringMap[] = {
    {"BUILTIN", 1},
    {"EXTERN", 2},
    {"INVALID", 0},
    {"NORMAL", 3},
    {"SIGNATURE", 4},
    {"ZZZ", 0},
};

const uint8_t FUN_KINDJumper[128] = {
 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 0, 255, 255, 1, 255, 255, 255, 2, 255, 255, 255, 255, 3, 255, 255, 255, 255, 4, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,};

const char* const MEM_KIND_ToStringMap[] = {
    "INVALID", // 0
    "RO", // 1
    "RW", // 2
    "TLS", // 3
    "FIX", // 4
    "EXTERN", // 5
    "BUILTIN", // 6
};
const char* EnumToString(MEM_KIND x) { return MEM_KIND_ToStringMap[unsigned(x)]; }


const struct StringKind MEM_KINDFromStringMap[] = {
    {"BUILTIN", 6},
    {"EXTERN", 5},
    {"FIX", 4},
    {"INVALID", 0},
    {"RO", 1},
    {"RW", 2},
    {"TLS", 3},
    {"ZZZ", 0},
};

const uint8_t MEM_KINDJumper[128] = {
 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 0, 255, 255, 1, 2, 255, 255, 3, 255, 255, 255, 255, 255, 255, 255, 255, 4, 255, 6, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,};

const char* const TC_ToStringMap[] = {
    "INVALID", // 0
    "ANY", // 1
    "ADDR_NUM", // 2
    "ADDR_INT", // 3
    "NUM", // 4
    "FLT", // 5
    "INT", // 6
    "ADDR", // 7
    "CODE", // 8
    "UINT", // 9
    "SINT", // 10
    "OFFSET", // 11
    "", // 12
    "", // 13
    "", // 14
    "", // 15
    "", // 16
    "", // 17
    "", // 18
    "", // 19
    "SAME_AS_PREV", // 20
    "", // 21
    "SAME_SIZE_AS_PREV", // 22
};
const char* EnumToString(TC x) { return TC_ToStringMap[unsigned(x)]; }


const struct StringKind TCFromStringMap[] = {
    {"ADDR", 7},
    {"ADDR_INT", 3},
    {"ADDR_NUM", 2},
    {"ANY", 1},
    {"CODE", 8},
    {"FLT", 5},
    {"INT", 6},
    {"INVALID", 0},
    {"NUM", 4},
    {"OFFSET", 11},
    {"SAME_AS_PREV", 20},
    {"SAME_SIZE_AS_PREV", 22},
    {"SINT", 10},
    {"UINT", 9},
    {"ZZZ", 0},
};

const uint8_t TCJumper[128] = {
 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 0, 255, 4, 255, 255, 5, 255, 255, 6, 255, 255, 255, 255, 8, 9, 255, 255, 255, 10, 255, 13, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,};

const char* const DK_ToStringMap[] = {
    "INVALID", // 0
    "", // 1
    "", // 2
    "", // 3
    "", // 4
    "", // 5
    "", // 6
    "", // 7
    "", // 8
    "", // 9
    "", // 10
    "", // 11
    "", // 12
    "", // 13
    "", // 14
    "", // 15
    "", // 16
    "", // 17
    "", // 18
    "", // 19
    "", // 20
    "", // 21
    "", // 22
    "", // 23
    "", // 24
    "", // 25
    "", // 26
    "", // 27
    "", // 28
    "", // 29
    "", // 30
    "", // 31
    "S8", // 32
    "S16", // 33
    "S32", // 34
    "S64", // 35
    "", // 36
    "", // 37
    "", // 38
    "", // 39
    "", // 40
    "", // 41
    "", // 42
    "", // 43
    "", // 44
    "", // 45
    "", // 46
    "", // 47
    "", // 48
    "", // 49
    "", // 50
    "", // 51
    "", // 52
    "", // 53
    "", // 54
    "", // 55
    "", // 56
    "", // 57
    "", // 58
    "", // 59
    "", // 60
    "", // 61
    "", // 62
    "", // 63
    "U8", // 64
    "U16", // 65
    "U32", // 66
    "U64", // 67
    "", // 68
    "", // 69
    "", // 70
    "", // 71
    "", // 72
    "", // 73
    "", // 74
    "", // 75
    "", // 76
    "", // 77
    "", // 78
    "", // 79
    "", // 80
    "", // 81
    "", // 82
    "", // 83
    "", // 84
    "", // 85
    "", // 86
    "", // 87
    "", // 88
    "", // 89
    "", // 90
    "", // 91
    "", // 92
    "", // 93
    "", // 94
    "", // 95
    "F8", // 96
    "F16", // 97
    "F32", // 98
    "F64", // 99
    "", // 100
    "", // 101
    "", // 102
    "", // 103
    "", // 104
    "", // 105
    "", // 106
    "", // 107
    "", // 108
    "", // 109
    "", // 110
    "", // 111
    "", // 112
    "", // 113
    "", // 114
    "", // 115
    "", // 116
    "", // 117
    "", // 118
    "", // 119
    "", // 120
    "", // 121
    "", // 122
    "", // 123
    "", // 124
    "", // 125
    "", // 126
    "", // 127
    "", // 128
    "", // 129
    "A32", // 130
    "A64", // 131
    "", // 132
    "", // 133
    "", // 134
    "", // 135
    "", // 136
    "", // 137
    "", // 138
    "", // 139
    "", // 140
    "", // 141
    "", // 142
    "", // 143
    "", // 144
    "", // 145
    "", // 146
    "", // 147
    "", // 148
    "", // 149
    "", // 150
    "", // 151
    "", // 152
    "", // 153
    "", // 154
    "", // 155
    "", // 156
    "", // 157
    "", // 158
    "", // 159
    "", // 160
    "", // 161
    "C32", // 162
    "C64", // 163
};
const char* EnumToString(DK x) { return DK_ToStringMap[unsigned(x)]; }


const struct StringKind DKFromStringMap[] = {
    {"A32", 130},
    {"A64", 131},
    {"C32", 162},
    {"C64", 163},
    {"F16", 97},
    {"F32", 98},
    {"F64", 99},
    {"F8", 96},
    {"INVALID", 0},
    {"S16", 33},
    {"S32", 34},
    {"S64", 35},
    {"S8", 32},
    {"U16", 65},
    {"U32", 66},
    {"U64", 67},
    {"U8", 64},
    {"ZZZ", 0},
};

const uint8_t DKJumper[128] = {
 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 0, 255, 2, 255, 255, 4, 255, 255, 8, 255, 255, 255, 255, 255, 255, 255, 255, 255, 9, 255, 13, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,};

const char* const OP_KIND_ToStringMap[] = {
    "INVALID", // 0
    "REG", // 1
    "CONST", // 2
    "REG_OR_CONST", // 3
    "BBL", // 4
    "MEM", // 5
    "STK", // 6
    "FUN", // 7
    "JTB", // 8
    "", // 9
    "", // 10
    "", // 11
    "", // 12
    "", // 13
    "", // 14
    "", // 15
    "", // 16
    "", // 17
    "", // 18
    "", // 19
    "TYPE_LIST", // 20
    "DATA_KIND", // 21
    "", // 22
    "MEM_KIND", // 23
    "FUN_KIND", // 24
    "FIELD", // 25
    "NAME", // 26
    "NAME_LIST", // 27
    "INT", // 28
    "BBL_TAB", // 29
    "BYTES", // 30
};
const char* EnumToString(OP_KIND x) { return OP_KIND_ToStringMap[unsigned(x)]; }


const struct StringKind OPCFromStringMap[] = {
    {".addr.fun", 3},
    {".addr.mem", 4},
    {".bbl", 6},
    {".data", 2},
    {".fun", 5},
    {".jtb", 9},
    {".mem", 1},
    {".reg", 7},
    {".stk", 8},
    {"acos", 92},
    {"add", 16},
    {"and", 25},
    {"asin", 91},
    {"atan", 93},
    {"bcopy", 184},
    {"beq", 32},
    {"bitcast", 51},
    {"ble", 35},
    {"blt", 34},
    {"bne", 33},
    {"bra", 41},
    {"bsr", 43},
    {"bzero", 186},
    {"cas", 76},
    {"cas.mem", 77},
    {"cas.stk", 78},
    {"ceil", 80},
    {"clmul", 22},
    {"cmpeq", 53},
    {"cmplt", 54},
    {"cntlz", 96},
    {"cntpop", 98},
    {"cnttz", 97},
    {"conv", 50},
    {"copysign", 23},
    {"cos", 89},
    {"div", 19},
    {"exp", 94},
    {"floor", 81},
    {"jsr", 44},
    {"ld", 64},
    {"ld.mem", 65},
    {"ld.stk", 66},
    {"lea", 56},
    {"lea.fun", 59},
    {"lea.mem", 57},
    {"lea.stk", 58},
    {"log", 95},
    {"mov", 52},
    {"mul", 18},
    {"nop", 112},
    {"nop1", 113},
    {"or", 26},
    {"poparg", 49},
    {"pusharg", 48},
    {"rem", 20},
    {"ret", 42},
    {"round", 82},
    {"shl", 27},
    {"shr", 28},
    {"sin", 88},
    {"sqrt", 84},
    {"st", 72},
    {"st.mem", 73},
    {"st.stk", 74},
    {"sub", 17},
    {"switch", 40},
    {"syscall", 45},
    {"tan", 90},
    {"trap", 46},
    {"trunc", 83},
    {"xor", 24},
    {"ZZZ", 0},
};

const uint8_t OPCJumper[128] = {
 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 0, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 9, 14, 23, 36, 37, 38, 255, 255, 255, 39, 255, 40, 48, 50, 52, 53, 255, 55, 58, 68, 255, 255, 255, 71, 255, 255, 255, 255, 255, 255, 255,};
const Opcode GlobalOpcodes[256] = {
     {  //  0 
       {}, 
       OPC_KIND::INVALID, OPC_GENUS::INVALID, 0, 0,
       {}, 
       "", 0 },
     {  //  1 .mem
       {OP_KIND::NAME, OP_KIND::INT, OP_KIND::MEM_KIND}, 
       OPC_KIND::DIRECTIVE, OPC_GENUS::BASE, 3, 0,
       {TC::INVALID, TC::INVALID, TC::INVALID}, 
       ".mem", 0 },
     {  //  2 .data
       {OP_KIND::INT, OP_KIND::BYTES}, 
       OPC_KIND::DIRECTIVE, OPC_GENUS::BASE, 2, 0,
       {TC::INVALID, TC::INVALID}, 
       ".data", 0 },
     {  //  3 .addr.fun
       {OP_KIND::INT, OP_KIND::FUN}, 
       OPC_KIND::DIRECTIVE, OPC_GENUS::BASE, 2, 0,
       {TC::INVALID, TC::INVALID}, 
       ".addr.fun", 0 },
     {  //  4 .addr.mem
       {OP_KIND::INT, OP_KIND::MEM, OP_KIND::INT}, 
       OPC_KIND::DIRECTIVE, OPC_GENUS::BASE, 3, 0,
       {TC::INVALID, TC::INVALID, TC::INVALID}, 
       ".addr.mem", 0 },
     {  //  5 .fun
       {OP_KIND::NAME, OP_KIND::FUN_KIND, OP_KIND::TYPE_LIST, OP_KIND::TYPE_LIST}, 
       OPC_KIND::DIRECTIVE, OPC_GENUS::BASE, 4, 0,
       {TC::INVALID, TC::INVALID, TC::INVALID, TC::INVALID}, 
       ".fun", 0 },
     {  //  6 .bbl
       {OP_KIND::NAME}, 
       OPC_KIND::DIRECTIVE, OPC_GENUS::BASE, 1, 0,
       {TC::INVALID}, 
       ".bbl", 0 },
     {  //  7 .reg
       {OP_KIND::DATA_KIND, OP_KIND::NAME_LIST}, 
       OPC_KIND::DIRECTIVE, OPC_GENUS::BASE, 2, 0,
       {TC::INVALID, TC::INVALID}, 
       ".reg", 0 },
     {  //  8 .stk
       {OP_KIND::NAME, OP_KIND::INT, OP_KIND::INT}, 
       OPC_KIND::DIRECTIVE, OPC_GENUS::BASE, 3, 0,
       {TC::INVALID, TC::INVALID, TC::INVALID}, 
       ".stk", 0 },
     {  //  9 .jtb
       {OP_KIND::NAME, OP_KIND::INT, OP_KIND::BBL, OP_KIND::BBL_TAB}, 
       OPC_KIND::DIRECTIVE, OPC_GENUS::BASE, 4, 0,
       {TC::INVALID, TC::INVALID, TC::INVALID, TC::INVALID}, 
       ".jtb", 0 },
     {  //  a 
       {}, 
       OPC_KIND::INVALID, OPC_GENUS::INVALID, 0, 0,
       {}, 
       "", 0 },
     {  //  b 
       {}, 
       OPC_KIND::INVALID, OPC_GENUS::INVALID, 0, 0,
       {}, 
       "", 0 },
     {  //  c 
       {}, 
       OPC_KIND::INVALID, OPC_GENUS::INVALID, 0, 0,
       {}, 
       "", 0 },
     {  //  d 
       {}, 
       OPC_KIND::INVALID, OPC_GENUS::INVALID, 0, 0,
       {}, 
       "", 0 },
     {  //  e 
       {}, 
       OPC_KIND::INVALID, OPC_GENUS::INVALID, 0, 0,
       {}, 
       "", 0 },
     {  //  f 
       {}, 
       OPC_KIND::INVALID, OPC_GENUS::INVALID, 0, 0,
       {}, 
       "", 0 },
     {  // 10 add
       {OP_KIND::REG, OP_KIND::REG_OR_CONST, OP_KIND::REG_OR_CONST}, 
       OPC_KIND::ALU, OPC_GENUS::BASE, 3, 1,
       {TC::NUM, TC::SAME_AS_PREV, TC::SAME_AS_PREV}, 
       "add", OA::COMMUTATIVE },
     {  // 11 sub
       {OP_KIND::REG, OP_KIND::REG_OR_CONST, OP_KIND::REG_OR_CONST}, 
       OPC_KIND::ALU, OPC_GENUS::BASE, 3, 1,
       {TC::NUM, TC::SAME_AS_PREV, TC::SAME_AS_PREV}, 
       "sub", 0 },
     {  // 12 mul
       {OP_KIND::REG, OP_KIND::REG_OR_CONST, OP_KIND::REG_OR_CONST}, 
       OPC_KIND::ALU, OPC_GENUS::BASE, 3, 1,
       {TC::NUM, TC::SAME_AS_PREV, TC::SAME_AS_PREV}, 
       "mul", OA::COMMUTATIVE },
     {  // 13 div
       {OP_KIND::REG, OP_KIND::REG_OR_CONST, OP_KIND::REG_OR_CONST}, 
       OPC_KIND::ALU, OPC_GENUS::BASE, 3, 1,
       {TC::NUM, TC::SAME_AS_PREV, TC::SAME_AS_PREV}, 
       "div", 0 },
     {  // 14 rem
       {OP_KIND::REG, OP_KIND::REG_OR_CONST, OP_KIND::REG_OR_CONST}, 
       OPC_KIND::ALU, OPC_GENUS::BASE, 3, 1,
       {TC::INT, TC::SAME_AS_PREV, TC::SAME_AS_PREV}, 
       "rem", 0 },
     {  // 15 
       {}, 
       OPC_KIND::INVALID, OPC_GENUS::INVALID, 0, 0,
       {}, 
       "", 0 },
     {  // 16 clmul
       {OP_KIND::REG, OP_KIND::REG_OR_CONST, OP_KIND::REG_OR_CONST}, 
       OPC_KIND::ALU, OPC_GENUS::BASE, 3, 1,
       {TC::INT, TC::SAME_AS_PREV, TC::SAME_AS_PREV}, 
       "clmul", 0 },
     {  // 17 copysign
       {OP_KIND::REG, OP_KIND::REG_OR_CONST, OP_KIND::REG_OR_CONST}, 
       OPC_KIND::ALU, OPC_GENUS::BASE, 3, 1,
       {TC::FLT, TC::SAME_AS_PREV, TC::SAME_AS_PREV}, 
       "copysign", 0 },
     {  // 18 xor
       {OP_KIND::REG, OP_KIND::REG_OR_CONST, OP_KIND::REG_OR_CONST}, 
       OPC_KIND::ALU, OPC_GENUS::BASE, 3, 1,
       {TC::INT, TC::SAME_AS_PREV, TC::SAME_AS_PREV}, 
       "xor", OA::COMMUTATIVE },
     {  // 19 and
       {OP_KIND::REG, OP_KIND::REG_OR_CONST, OP_KIND::REG_OR_CONST}, 
       OPC_KIND::ALU, OPC_GENUS::BASE, 3, 1,
       {TC::INT, TC::SAME_AS_PREV, TC::SAME_AS_PREV}, 
       "and", OA::COMMUTATIVE },
     {  // 1a or
       {OP_KIND::REG, OP_KIND::REG_OR_CONST, OP_KIND::REG_OR_CONST}, 
       OPC_KIND::ALU, OPC_GENUS::BASE, 3, 1,
       {TC::INT, TC::SAME_AS_PREV, TC::SAME_AS_PREV}, 
       "or", OA::COMMUTATIVE },
     {  // 1b shl
       {OP_KIND::REG, OP_KIND::REG_OR_CONST, OP_KIND::REG_OR_CONST}, 
       OPC_KIND::ALU, OPC_GENUS::BASE, 3, 1,
       {TC::INT, TC::SAME_AS_PREV, TC::SAME_AS_PREV}, 
       "shl", 0 },
     {  // 1c shr
       {OP_KIND::REG, OP_KIND::REG_OR_CONST, OP_KIND::REG_OR_CONST}, 
       OPC_KIND::ALU, OPC_GENUS::BASE, 3, 1,
       {TC::INT, TC::SAME_AS_PREV, TC::SAME_AS_PREV}, 
       "shr", 0 },
     {  // 1d 
       {}, 
       OPC_KIND::INVALID, OPC_GENUS::INVALID, 0, 0,
       {}, 
       "", 0 },
     {  // 1e 
       {}, 
       OPC_KIND::INVALID, OPC_GENUS::INVALID, 0, 0,
       {}, 
       "", 0 },
     {  // 1f 
       {}, 
       OPC_KIND::INVALID, OPC_GENUS::INVALID, 0, 0,
       {}, 
       "", 0 },
     {  // 20 beq
       {OP_KIND::REG_OR_CONST, OP_KIND::REG_OR_CONST, OP_KIND::BBL}, 
       OPC_KIND::COND_BRA, OPC_GENUS::BASE, 3, 0,
       {TC::ANY, TC::SAME_AS_PREV, TC::INVALID}, 
       "beq", OA::BBL_TERMINATOR|OA::COMMUTATIVE },
     {  // 21 bne
       {OP_KIND::REG_OR_CONST, OP_KIND::REG_OR_CONST, OP_KIND::BBL}, 
       OPC_KIND::COND_BRA, OPC_GENUS::BASE, 3, 0,
       {TC::ANY, TC::SAME_AS_PREV, TC::INVALID}, 
       "bne", OA::BBL_TERMINATOR|OA::COMMUTATIVE },
     {  // 22 blt
       {OP_KIND::REG_OR_CONST, OP_KIND::REG_OR_CONST, OP_KIND::BBL}, 
       OPC_KIND::COND_BRA, OPC_GENUS::BASE, 3, 0,
       {TC::ADDR_NUM, TC::SAME_AS_PREV, TC::INVALID}, 
       "blt", OA::BBL_TERMINATOR },
     {  // 23 ble
       {OP_KIND::REG_OR_CONST, OP_KIND::REG_OR_CONST, OP_KIND::BBL}, 
       OPC_KIND::COND_BRA, OPC_GENUS::BASE, 3, 0,
       {TC::ADDR_NUM, TC::SAME_AS_PREV, TC::INVALID}, 
       "ble", OA::BBL_TERMINATOR },
     {  // 24 
       {}, 
       OPC_KIND::INVALID, OPC_GENUS::INVALID, 0, 0,
       {}, 
       "", 0 },
     {  // 25 
       {}, 
       OPC_KIND::INVALID, OPC_GENUS::INVALID, 0, 0,
       {}, 
       "", 0 },
     {  // 26 
       {}, 
       OPC_KIND::INVALID, OPC_GENUS::INVALID, 0, 0,
       {}, 
       "", 0 },
     {  // 27 
       {}, 
       OPC_KIND::INVALID, OPC_GENUS::INVALID, 0, 0,
       {}, 
       "", 0 },
     {  // 28 switch
       {OP_KIND::REG, OP_KIND::JTB}, 
       OPC_KIND::SWITCH, OPC_GENUS::BASE, 2, 0,
       {TC::UINT, TC::INVALID}, 
       "switch", OA::BBL_TERMINATOR|OA::NO_FALL_THROUGH },
     {  // 29 bra
       {OP_KIND::BBL}, 
       OPC_KIND::BRA, OPC_GENUS::BASE, 1, 0,
       {TC::INVALID}, 
       "bra", OA::BBL_TERMINATOR|OA::NO_FALL_THROUGH },
     {  // 2a ret
       {}, 
       OPC_KIND::RET, OPC_GENUS::BASE, 0, 0,
       {}, 
       "ret", OA::BBL_TERMINATOR|OA::NO_FALL_THROUGH },
     {  // 2b bsr
       {OP_KIND::FUN}, 
       OPC_KIND::BSR, OPC_GENUS::BASE, 1, 0,
       {TC::INVALID}, 
       "bsr", OA::CALL },
     {  // 2c jsr
       {OP_KIND::REG, OP_KIND::FUN}, 
       OPC_KIND::JSR, OPC_GENUS::BASE, 2, 0,
       {TC::CODE, TC::INVALID}, 
       "jsr", OA::CALL },
     {  // 2d syscall
       {OP_KIND::FUN, OP_KIND::CONST}, 
       OPC_KIND::SYSCALL, OPC_GENUS::BASE, 2, 0,
       {TC::INVALID, TC::UINT}, 
       "syscall", OA::CALL },
     {  // 2e trap
       {}, 
       OPC_KIND::RET, OPC_GENUS::BASE, 0, 0,
       {}, 
       "trap", OA::BBL_TERMINATOR|OA::NO_FALL_THROUGH },
     {  // 2f 
       {}, 
       OPC_KIND::INVALID, OPC_GENUS::INVALID, 0, 0,
       {}, 
       "", 0 },
     {  // 30 pusharg
       {OP_KIND::REG_OR_CONST}, 
       OPC_KIND::PUSHARG, OPC_GENUS::BASE, 1, 0,
       {TC::ANY}, 
       "pusharg", OA::SPECIAL },
     {  // 31 poparg
       {OP_KIND::REG}, 
       OPC_KIND::POPARG, OPC_GENUS::BASE, 1, 1,
       {TC::ANY}, 
       "poparg", OA::SPECIAL },
     {  // 32 conv
       {OP_KIND::REG, OP_KIND::REG_OR_CONST}, 
       OPC_KIND::CONV, OPC_GENUS::BASE, 2, 1,
       {TC::NUM, TC::NUM}, 
       "conv", 0 },
     {  // 33 bitcast
       {OP_KIND::REG, OP_KIND::REG_OR_CONST}, 
       OPC_KIND::CONV, OPC_GENUS::BASE, 2, 1,
       {TC::ANY, TC::SAME_SIZE_AS_PREV}, 
       "bitcast", 0 },
     {  // 34 mov
       {OP_KIND::REG, OP_KIND::REG_OR_CONST}, 
       OPC_KIND::MOV, OPC_GENUS::BASE, 2, 1,
       {TC::ANY, TC::SAME_AS_PREV}, 
       "mov", 0 },
     {  // 35 cmpeq
       {OP_KIND::REG, OP_KIND::REG_OR_CONST, OP_KIND::REG_OR_CONST, OP_KIND::REG_OR_CONST, OP_KIND::REG_OR_CONST}, 
       OPC_KIND::CMP, OPC_GENUS::BASE, 5, 1,
       {TC::ANY, TC::SAME_AS_PREV, TC::SAME_AS_PREV, TC::ANY, TC::SAME_AS_PREV}, 
       "cmpeq", OA::COMMUTATIVE },
     {  // 36 cmplt
       {OP_KIND::REG, OP_KIND::REG_OR_CONST, OP_KIND::REG_OR_CONST, OP_KIND::REG_OR_CONST, OP_KIND::REG_OR_CONST}, 
       OPC_KIND::CMP, OPC_GENUS::BASE, 5, 1,
       {TC::ANY, TC::SAME_AS_PREV, TC::SAME_AS_PREV, TC::ADDR_NUM, TC::SAME_AS_PREV}, 
       "cmplt", 0 },
     {  // 37 
       {}, 
       OPC_KIND::INVALID, OPC_GENUS::INVALID, 0, 0,
       {}, 
       "", 0 },
     {  // 38 lea
       {OP_KIND::REG, OP_KIND::REG_OR_CONST, OP_KIND::REG_OR_CONST}, 
       OPC_KIND::LEA, OPC_GENUS::BASE, 3, 1,
       {TC::ADDR, TC::SAME_AS_PREV, TC::OFFSET}, 
       "lea", 0 },
     {  // 39 lea.mem
       {OP_KIND::REG, OP_KIND::MEM, OP_KIND::REG_OR_CONST}, 
       OPC_KIND::LEA, OPC_GENUS::BASE, 3, 1,
       {TC::ADDR, TC::INVALID, TC::OFFSET}, 
       "lea.mem", 0 },
     {  // 3a lea.stk
       {OP_KIND::REG, OP_KIND::STK, OP_KIND::REG_OR_CONST}, 
       OPC_KIND::LEA, OPC_GENUS::BASE, 3, 1,
       {TC::ADDR, TC::INVALID, TC::OFFSET}, 
       "lea.stk", 0 },
     {  // 3b lea.fun
       {OP_KIND::REG, OP_KIND::FUN}, 
       OPC_KIND::LEA1, OPC_GENUS::BASE, 2, 1,
       {TC::CODE, TC::INVALID}, 
       "lea.fun", 0 },
     {  // 3c 
       {}, 
       OPC_KIND::INVALID, OPC_GENUS::INVALID, 0, 0,
       {}, 
       "", 0 },
     {  // 3d 
       {}, 
       OPC_KIND::INVALID, OPC_GENUS::INVALID, 0, 0,
       {}, 
       "", 0 },
     {  // 3e 
       {}, 
       OPC_KIND::INVALID, OPC_GENUS::INVALID, 0, 0,
       {}, 
       "", 0 },
     {  // 3f 
       {}, 
       OPC_KIND::INVALID, OPC_GENUS::INVALID, 0, 0,
       {}, 
       "", 0 },
     {  // 40 ld
       {OP_KIND::REG, OP_KIND::REG_OR_CONST, OP_KIND::REG_OR_CONST}, 
       OPC_KIND::LD, OPC_GENUS::BASE, 3, 1,
       {TC::ANY, TC::ADDR, TC::OFFSET}, 
       "ld", OA::MEM_RD },
     {  // 41 ld.mem
       {OP_KIND::REG, OP_KIND::MEM, OP_KIND::REG_OR_CONST}, 
       OPC_KIND::LD, OPC_GENUS::BASE, 3, 1,
       {TC::ANY, TC::INVALID, TC::OFFSET}, 
       "ld.mem", OA::MEM_RD },
     {  // 42 ld.stk
       {OP_KIND::REG, OP_KIND::STK, OP_KIND::REG_OR_CONST}, 
       OPC_KIND::LD, OPC_GENUS::BASE, 3, 1,
       {TC::ANY, TC::INVALID, TC::OFFSET}, 
       "ld.stk", OA::MEM_RD },
     {  // 43 
       {}, 
       OPC_KIND::INVALID, OPC_GENUS::INVALID, 0, 0,
       {}, 
       "", 0 },
     {  // 44 
       {}, 
       OPC_KIND::INVALID, OPC_GENUS::INVALID, 0, 0,
       {}, 
       "", 0 },
     {  // 45 
       {}, 
       OPC_KIND::INVALID, OPC_GENUS::INVALID, 0, 0,
       {}, 
       "", 0 },
     {  // 46 
       {}, 
       OPC_KIND::INVALID, OPC_GENUS::INVALID, 0, 0,
       {}, 
       "", 0 },
     {  // 47 
       {}, 
       OPC_KIND::INVALID, OPC_GENUS::INVALID, 0, 0,
       {}, 
       "", 0 },
     {  // 48 st
       {OP_KIND::REG, OP_KIND::REG_OR_CONST, OP_KIND::REG_OR_CONST}, 
       OPC_KIND::ST, OPC_GENUS::BASE, 3, 0,
       {TC::ADDR, TC::OFFSET, TC::ANY}, 
       "st", OA::MEM_WR },
     {  // 49 st.mem
       {OP_KIND::MEM, OP_KIND::REG_OR_CONST, OP_KIND::REG_OR_CONST}, 
       OPC_KIND::ST, OPC_GENUS::BASE, 3, 0,
       {TC::INVALID, TC::OFFSET, TC::ANY}, 
       "st.mem", OA::MEM_WR },
     {  // 4a st.stk
       {OP_KIND::STK, OP_KIND::REG_OR_CONST, OP_KIND::REG_OR_CONST}, 
       OPC_KIND::ST, OPC_GENUS::BASE, 3, 0,
       {TC::INVALID, TC::OFFSET, TC::ANY}, 
       "st.stk", OA::MEM_WR },
     {  // 4b 
       {}, 
       OPC_KIND::INVALID, OPC_GENUS::INVALID, 0, 0,
       {}, 
       "", 0 },
     {  // 4c cas
       {OP_KIND::REG, OP_KIND::REG_OR_CONST, OP_KIND::REG_OR_CONST, OP_KIND::REG, OP_KIND::REG_OR_CONST}, 
       OPC_KIND::CAS, OPC_GENUS::BASE, 5, 1,
       {TC::ANY, TC::SAME_AS_PREV, TC::SAME_AS_PREV, TC::ADDR, TC::OFFSET}, 
       "cas", OA::MEM_WR },
     {  // 4d cas.mem
       {OP_KIND::REG, OP_KIND::REG_OR_CONST, OP_KIND::REG_OR_CONST, OP_KIND::MEM, OP_KIND::REG_OR_CONST}, 
       OPC_KIND::CAS, OPC_GENUS::BASE, 5, 1,
       {TC::ANY, TC::SAME_AS_PREV, TC::SAME_AS_PREV, TC::INVALID, TC::OFFSET}, 
       "cas.mem", OA::MEM_WR },
     {  // 4e cas.stk
       {OP_KIND::REG, OP_KIND::REG_OR_CONST, OP_KIND::REG_OR_CONST, OP_KIND::STK, OP_KIND::REG_OR_CONST}, 
       OPC_KIND::CAS, OPC_GENUS::BASE, 5, 1,
       {TC::ANY, TC::SAME_AS_PREV, TC::SAME_AS_PREV, TC::INVALID, TC::OFFSET}, 
       "cas.stk", OA::MEM_WR },
     {  // 4f 
       {}, 
       OPC_KIND::INVALID, OPC_GENUS::INVALID, 0, 0,
       {}, 
       "", 0 },
     {  // 50 ceil
       {OP_KIND::REG, OP_KIND::REG_OR_CONST}, 
       OPC_KIND::ALU1, OPC_GENUS::BASE, 2, 1,
       {TC::FLT, TC::SAME_AS_PREV}, 
       "ceil", 0 },
     {  // 51 floor
       {OP_KIND::REG, OP_KIND::REG_OR_CONST}, 
       OPC_KIND::ALU1, OPC_GENUS::BASE, 2, 1,
       {TC::FLT, TC::SAME_AS_PREV}, 
       "floor", 0 },
     {  // 52 round
       {OP_KIND::REG, OP_KIND::REG_OR_CONST}, 
       OPC_KIND::ALU1, OPC_GENUS::BASE, 2, 1,
       {TC::FLT, TC::SAME_AS_PREV}, 
       "round", 0 },
     {  // 53 trunc
       {OP_KIND::REG, OP_KIND::REG_OR_CONST}, 
       OPC_KIND::ALU1, OPC_GENUS::BASE, 2, 1,
       {TC::FLT, TC::SAME_AS_PREV}, 
       "trunc", 0 },
     {  // 54 sqrt
       {OP_KIND::REG, OP_KIND::REG_OR_CONST}, 
       OPC_KIND::ALU1, OPC_GENUS::BASE, 2, 1,
       {TC::FLT, TC::SAME_AS_PREV}, 
       "sqrt", 0 },
     {  // 55 
       {}, 
       OPC_KIND::INVALID, OPC_GENUS::INVALID, 0, 0,
       {}, 
       "", 0 },
     {  // 56 
       {}, 
       OPC_KIND::INVALID, OPC_GENUS::INVALID, 0, 0,
       {}, 
       "", 0 },
     {  // 57 
       {}, 
       OPC_KIND::INVALID, OPC_GENUS::INVALID, 0, 0,
       {}, 
       "", 0 },
     {  // 58 
       {}, 
       OPC_KIND::INVALID, OPC_GENUS::INVALID, 0, 0,
       {}, 
       "", 0 },
     {  // 59 
       {}, 
       OPC_KIND::INVALID, OPC_GENUS::INVALID, 0, 0,
       {}, 
       "", 0 },
     {  // 5a 
       {}, 
       OPC_KIND::INVALID, OPC_GENUS::INVALID, 0, 0,
       {}, 
       "", 0 },
     {  // 5b 
       {}, 
       OPC_KIND::INVALID, OPC_GENUS::INVALID, 0, 0,
       {}, 
       "", 0 },
     {  // 5c 
       {}, 
       OPC_KIND::INVALID, OPC_GENUS::INVALID, 0, 0,
       {}, 
       "", 0 },
     {  // 5d 
       {}, 
       OPC_KIND::INVALID, OPC_GENUS::INVALID, 0, 0,
       {}, 
       "", 0 },
     {  // 5e 
       {}, 
       OPC_KIND::INVALID, OPC_GENUS::INVALID, 0, 0,
       {}, 
       "", 0 },
     {  // 5f 
       {}, 
       OPC_KIND::INVALID, OPC_GENUS::INVALID, 0, 0,
       {}, 
       "", 0 },
     {  // 60 cntlz
       {OP_KIND::REG, OP_KIND::REG_OR_CONST}, 
       OPC_KIND::ALU1, OPC_GENUS::BASE, 2, 1,
       {TC::INT, TC::SAME_AS_PREV}, 
       "cntlz", 0 },
     {  // 61 cnttz
       {OP_KIND::REG, OP_KIND::REG_OR_CONST}, 
       OPC_KIND::ALU1, OPC_GENUS::BASE, 2, 1,
       {TC::INT, TC::SAME_AS_PREV}, 
       "cnttz", 0 },
     {  // 62 cntpop
       {OP_KIND::REG, OP_KIND::REG_OR_CONST}, 
       OPC_KIND::ALU1, OPC_GENUS::BASE, 2, 1,
       {TC::INT, TC::SAME_AS_PREV}, 
       "cntpop", 0 },
     {  // 63 
       {}, 
       OPC_KIND::INVALID, OPC_GENUS::INVALID, 0, 0,
       {}, 
       "", 0 },
     {  // 64 
       {}, 
       OPC_KIND::INVALID, OPC_GENUS::INVALID, 0, 0,
       {}, 
       "", 0 },
     {  // 65 
       {}, 
       OPC_KIND::INVALID, OPC_GENUS::INVALID, 0, 0,
       {}, 
       "", 0 },
     {  // 66 
       {}, 
       OPC_KIND::INVALID, OPC_GENUS::INVALID, 0, 0,
       {}, 
       "", 0 },
     {  // 67 
       {}, 
       OPC_KIND::INVALID, OPC_GENUS::INVALID, 0, 0,
       {}, 
       "", 0 },
     {  // 68 
       {}, 
       OPC_KIND::INVALID, OPC_GENUS::INVALID, 0, 0,
       {}, 
       "", 0 },
     {  // 69 
       {}, 
       OPC_KIND::INVALID, OPC_GENUS::INVALID, 0, 0,
       {}, 
       "", 0 },
     {  // 6a 
       {}, 
       OPC_KIND::INVALID, OPC_GENUS::INVALID, 0, 0,
       {}, 
       "", 0 },
     {  // 6b 
       {}, 
       OPC_KIND::INVALID, OPC_GENUS::INVALID, 0, 0,
       {}, 
       "", 0 },
     {  // 6c 
       {}, 
       OPC_KIND::INVALID, OPC_GENUS::INVALID, 0, 0,
       {}, 
       "", 0 },
     {  // 6d 
       {}, 
       OPC_KIND::INVALID, OPC_GENUS::INVALID, 0, 0,
       {}, 
       "", 0 },
     {  // 6e 
       {}, 
       OPC_KIND::INVALID, OPC_GENUS::INVALID, 0, 0,
       {}, 
       "", 0 },
     {  // 6f 
       {}, 
       OPC_KIND::INVALID, OPC_GENUS::INVALID, 0, 0,
       {}, 
       "", 0 },
     {  // 70 nop
       {}, 
       OPC_KIND::NOP, OPC_GENUS::BASE, 0, 0,
       {}, 
       "nop", 0 },
     {  // 71 nop1
       {OP_KIND::REG}, 
       OPC_KIND::NOP1, OPC_GENUS::BASE, 1, 1,
       {TC::ANY}, 
       "nop1", OA::SPECIAL },
};

/* @AUTOGEN-END@ */

int string_view_cmp(const char* a, std::string_view b) {
  int x = strncmp(a, b.data(), b.size());
  if (x == 0 && a[b.size()] != 0) return 1;
  return x;
}

static uint8_t LinearSearch(const StringKind* table, const uint8_t* jumper,
                     std::string_view sym, uint8_t def_val) {
    ASSERT(sym[0] <= 127, "");
    uint8_t start = jumper[uint8_t(sym[0])];
    if (start == 255) return def_val;
    while (true) {
        int cmp = string_view_cmp(table[start].name, sym);
        if (cmp == 0) {
          return table[start].kind;
        }
        ++start;
        if (cmp > 0) break;
    }
    return def_val;
}

MEM_KIND MKFromString(std::string_view name) {
  return MEM_KIND(LinearSearch(MEM_KINDFromStringMap, MEM_KINDJumper, name, 0));
}

OPC_GENUS OpcGenusFromString(std::string_view name) {
 return OPC_GENUS(LinearSearch(OPC_GENUSFromStringMap, OPC_GENUSJumper, name, 0));
}

FUN_KIND FKFromString(std::string_view name) {
 return FUN_KIND(LinearSearch(FUN_KINDFromStringMap, FUN_KINDJumper, name, 0));
}

DK DKFromString(std::string_view name) {
 return DK(LinearSearch(DKFromStringMap, DKJumper, name, 0));
}

TC TCFromString(std::string_view name) {
 return TC(LinearSearch(TCFromStringMap, TCJumper, name, 0));
}

OPC OPCFromString(std::string_view name) {
  return OPC(LinearSearch(OPCFromStringMap, OPCJumper, name, 0));
}

}  // namespace cwerg::base

