#pragma once

// (c) Robert Muth - see LICENSE for more info
// NOTE: this file is PARTIALLY autogenerated via: ./opcode_tab.py gen_h

#include "Elf/enum_gen.h"  // for reloc types

#include <cstdint>
#include <string_view>

namespace cwerg::x64 {

constexpr const unsigned NA = 15;

using namespace cwerg;

#include "CpuX64/opcode_gen_enum.h"

/* @AUTOGEN-START@ */
constexpr const unsigned MAX_OPERAND_COUNT = 6;
constexpr const unsigned MAX_INSTRUCTION_LENGTH = 11;
constexpr const unsigned MAX_INSTRUCTION_LENGTH_WITH_PREFIXES = 15;
constexpr const unsigned MAX_INSTRUCTION_NAME_LENGTH = 22;
constexpr const unsigned MAX_FINGERPRINT = 6000;

enum class MEM_WIDTH : uint8_t {
    NONE = 1,
    SIB = 2,
    SIB_BP_DISP = 3,
    RIP_DISP = 4,
};

enum class OK : uint8_t {
    RIP_BASE = 1,
    MODRM_RM_BASE = 2,
    OFFABS8 = 3,
    OFFABS32 = 4,
    SIB_SCALE = 5,
    SIB_INDEX = 6,
    SIB_BASE = 7,
    SIB_INDEX_AS_BASE = 8,
    IMM8 = 10,
    IMM16 = 11,
    IMM32 = 12,
    OFFPCREL8 = 13,
    OFFPCREL32 = 14,
    IMM8_16 = 17,
    IMM8_32 = 18,
    IMM8_64 = 19,
    IMM32_64 = 20,
    IMM64 = 21,
    BYTE_WITH_REG8 = 24,
    BYTE_WITH_REG16 = 25,
    BYTE_WITH_REG32 = 26,
    BYTE_WITH_REG64 = 27,
    MODRM_RM_REG8 = 28,
    MODRM_RM_REG16 = 29,
    MODRM_RM_REG32 = 30,
    MODRM_RM_REG64 = 31,
    MODRM_RM_XREG32 = 32,
    MODRM_RM_XREG64 = 33,
    MODRM_RM_XREG128 = 34,
    MODRM_REG8 = 35,
    MODRM_REG16 = 36,
    MODRM_REG32 = 37,
    MODRM_REG64 = 38,
    MODRM_XREG32 = 39,
    MODRM_XREG64 = 40,
    MODRM_XREG128 = 41,
    IMPLICIT_AL = 50,
    IMPLICIT_AX = 51,
    IMPLICIT_EAX = 52,
    IMPLICIT_RAX = 53,
    IMPLICIT_DX = 54,
    IMPLICIT_EDX = 55,
    IMPLICIT_RDX = 56,
    IMPLICIT_CL = 57,
    IMPLICIT_1 = 68,
};
/* @AUTOGEN-END@ */

// Describes a class of instructions structurally (read-only data).
struct Opcode {
  uint8_t num_fields : 4;
  uint8_t num_bytes : 4;
  uint8_t mem_width_log: 3;  // 8 = 1, 16 = 2, 32 = 3, 64 = 4, 128 = 5
  uint8_t rexw : 1;
  // NA (15) == pos not set
  uint8_t modrm_pos : 4;
  uint8_t sib_pos : 4;
  uint8_t offset_pos : 4;
  uint8_t imm_pos : 4;
  uint8_t byte_with_reg_pos : 4;
  OK fields[MAX_OPERAND_COUNT];          // 6
  uint8_t data[MAX_INSTRUCTION_LENGTH];  // 11
  uint8_t mask[MAX_INSTRUCTION_LENGTH];  // 11
};

static_assert(sizeof(Opcode) == 32);
static_assert(MAX_INSTRUCTION_NAME_LENGTH < 24);  // need null byte

// Indexed by OPC
extern const Opcode OpcodeTableEncodings[];  // see
extern const char OpcodeTableNames[][24];   // see

inline const char* OpcodeName(const Opcode* opcode) {
  return OpcodeTableNames[opcode - OpcodeTableEncodings];
}

extern const Opcode* FindOpcode(std::string_view data);

// Find the Opcode or null with the given name
extern const Opcode* FindOpcodeForMnemonic(std::string_view name);

// Decoded representation of the instruction word
struct Ins {
  const Opcode* opcode;
  // number of used entries is ArmOpcode.num_fields
  uint64_t operands[MAX_OPERAND_COUNT];
  // Relocation info
  std::string_view reloc_symbol;
  elf::RELOC_TYPE_X86_64 reloc_kind = elf::RELOC_TYPE_X86_64::NONE;
  uint8_t reloc_pos;  // index into  operands
  bool is_local_sym = false;
  bool has_reloc() const { return reloc_kind != elf::RELOC_TYPE_X86_64::NONE; }

  void clear_reloc() {
    if (has_reloc()) {
      reloc_kind = elf::RELOC_TYPE_X86_64::NONE;
      operands[reloc_pos] = 0;
    }
  }

  void set_reloc(elf::RELOC_TYPE_X86_64 kind,
                 bool is_local,
                 uint8_t pos,
                 std::string_view symbol) {
    reloc_kind = kind;
    is_local_sym = is_local;
    reloc_pos = pos;
    reloc_symbol = symbol;
  }
};

// Decode the instruction word `data`
// Returns true if successful
extern bool Disassemble(Ins* ins, std::string_view data);

// Encode the instruction
// Returns the instruction word. Asserts if unsuccessful
extern bool Assemble(const Ins& ins, uint8_t* data);

extern const char* EnumToString(OK x);

}  // namespace cwerg::x64
