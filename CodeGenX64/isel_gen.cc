// NOTE: this file is PARTIALLY autogenerated via: ./isel_tab.py gen_c
// (c) Robert Muth - see LICENSE for more info

#include "CodeGenX64/isel_gen.h"
#include "Base/opcode_gen.h"
#include "CpuX64//opcode_gen.h"

#include <cstdint>

namespace cwerg::code_gen_x64 {
namespace {
using namespace cwerg;
using namespace cwerg::base;

// +-prefix converts an enum the underlying integer type
template <typename T>
constexpr auto operator+(T e) noexcept
    -> std::enable_if_t<std::is_enum<T>::value, std::underlying_type_t<T>> {
  return static_cast<std::underlying_type_t<T>>(e);
}

#if 0
bool ImmStackFits(int64_t x,
                  bool assume_stk_op_matches,
                  unsigned bits,
                  unsigned scale_log) {
  if (assume_stk_op_matches) return true;
  if (x < 0) return false;
  if (x >= 1U << (bits + scale_log)) return false;
  return (x & ((1U << scale_log) - 1)) == 0;
}
#endif

// Note: some of these checks may not be necessary if we can rely on
// DK to enforce ranges/
bool MatchSignedRange(int64_t hi, Const num) {
  if (DKFlavor(ConstKind(num)) == DK_FLAVOR_U) {
    const uint64_t val = ConstValueU(num);
    return val <= uint64_t(hi);
  } else {
    const int64_t val = ConstValueACS(num);
    return (-hi - 1) <= val && val <= hi;
  }
}

bool MatchUnsignedRange(uint64_t hi, Const num) {
  if (DKFlavor(ConstKind(num)) == DK_FLAVOR_U) {
    const uint64_t val = ConstValueU(num);
    return val <= hi;
  } else {
    const int64_t val = ConstValueACS(num);
    return 0 <= val && uint64_t(val) <= hi;
  }
}

bool MatchesOpCurb(C curb, Handle op) {
  switch (curb) {
    case C::INVALID:
      ASSERT(op.kind() != RefKind::REG && op.kind() != RefKind::CONST, "");
      return true;
    case C::REG:
      return op.kind() == RefKind::REG &&
             RegStackSlot(Reg(op)).kind() != RefKind::STACK_SLOT;
    case C::SP_REG:
      return op.kind() == RefKind::REG &&
             RegStackSlot(Reg(op)).kind() == RefKind::STACK_SLOT;
    case C::ANY:
    case C::ZERO:
      ASSERT(false, "NYI " << EnumToString(curb));
      return true;
    case C::REG_RAX:
      return op.kind() == RefKind::REG && CpuRegNo(RegCpuReg(Reg(op))) == 0;
    case C::REG_RCX:
      return op.kind() == RefKind::REG && CpuRegNo(RegCpuReg(Reg(op))) == 1;
    case C::REG_RDX:
      return op.kind() == RefKind::REG && CpuRegNo(RegCpuReg(Reg(op))) == 2;
    case C::SIMM8:
      return MatchSignedRange((1LL << 7) - 1, Const(op));
    case C::SIMM16:
      return MatchSignedRange((1LL << 15) - 1, Const(op));
    case C::SIMM32:
      return MatchSignedRange((1LL << 31) - 1, Const(op));
    case C::SIMM64:
      return MatchSignedRange(0x7fff'ffff'ffff'ffff, Const(op));
    case C::UIMM8:
      return MatchUnsignedRange((1ULL << 8) - 1, Const(op));
    case C::UIMM16:
      return MatchUnsignedRange((1ULL << 16) - 1, Const(op));
    case C::UIMM32:
      return MatchUnsignedRange((1ULL << 32) - 1, Const(op));
    case C::UIMM64:
      return MatchUnsignedRange(0xffff'ffff'ffff'ffff, Const(op));
  }
  ASSERT(false, "unexpected C " << EnumToString(curb));
  return false;
}

uint64_t ExtractTypeMaskForPattern(Ins ins) {
  uint64_t reg_matcher = 0;
  unsigned num_ops = InsOpcode(ins).num_operands;
  for (unsigned i = 0; i < num_ops; ++i) {
    const Handle h = InsOperand(ins, i);
    if (h.kind() == RefKind::REG) {
      reg_matcher |= uint64_t(RegKind(Reg(h))) << 8 * i;
    } else if (h.kind() == RefKind::CONST) {
      reg_matcher |= uint64_t(ConstKind(Const(h))) << 8 * i;
    }
  }
  return reg_matcher;
}

bool PatternMatchesTypeCurbs(const Pattern& pat, uint64_t type_mask) {
  return type_mask == pat.type_curbs_as_int;
}

bool PatternMatchesOpCurbs(const Pattern& pat, Ins ins) {
  unsigned num_ops = InsOpcode(ins).num_operands;
  for (unsigned i = 0; i < num_ops; ++i) {
    if (!MatchesOpCurb(pat.op_curbs[i], InsOperand(ins, i))) return false;
  }
  return true;
}

}  // namespace

/* @AUTOGEN-START@ */

enum F {
  NO_INDEX = 4,
  NO_BASE = 4,
  RIP = 0,
  SCALE1 = 0,
  SCALE2 = 1,
  SCALE4 = 2,
  SCALE8 = 3,
  RAX = 0,
  RCX = 1,
  RDX = 2,
  RBX = 3,
  RSP = 4,
  RBP = 5,
  RSI = 6,
  RDI = 7,
  R8 = 8,
  R9 = 9,
  R10 = 10,
  R11 = 11,
  R12 = 12,
  R13 = 13,
  R14 = 14,
  R15 = 15,
  XMM0 = 0,
  XMM1 = 1,
  XMM2 = 2,
  XMM3 = 3,
  XMM4 = 4,
  XMM5 = 5,
  XMM6 = 6,
  XMM7 = 7,
  XMM8 = 8,
  XMM9 = 9,
  XMM10 = 10,
  XMM11 = 11,
  XMM12 = 12,
  XMM13 = 13,
  XMM14 = 14,
  XMM15 = 15,
};

const char* const C_ToStringMap[] = {
    "INVALID",  // 0
    "ZERO",     // 1
    "ANY",      // 2
    "REG",      // 3
    "SP_REG",   // 4
    "SIMM8",    // 5
    "SIMM16",   // 6
    "SIMM32",   // 7
    "SIMM64",   // 8
    "UIMM8",    // 9
    "UIMM16",   // 10
    "UIMM32",   // 11
    "UIMM64",   // 12
    "REG_RAX",  // 13
    "REG_RCX",  // 14
    "REG_RDX",  // 15
    "ZZZ",      // 16
};
const char* EnumToString(C x) { return C_ToStringMap[unsigned(x)]; }

const char* const P_ToStringMap[] = {
    "invalid",         // 0
    "reg01",           // 1
    "reg0",            // 2
    "reg1",            // 3
    "reg2",            // 4
    "reg3",            // 5
    "reg4",            // 6
    "tmp_gpr",         // 7
    "tmp_flt",         // 8
    "scratch_gpr",     // 9
    "num0",            // 10
    "num1",            // 11
    "num2",            // 12
    "num3",            // 13
    "num4",            // 14
    "spill01",         // 15
    "spill0",          // 16
    "spill1",          // 17
    "spill2",          // 18
    "stk1_offset2",    // 19
    "stk0_offset1",    // 20
    "stk1",            // 21
    "bbl0",            // 22
    "bbl1",            // 23
    "bbl2",            // 24
    "fun0",            // 25
    "mem0_num1_prel",  // 26
    "mem1_num2_prel",  // 27
    "fun1_prel",       // 28
    "jtb1_prel",       // 29
    "ZZZ",             // 30
};
const char* EnumToString(P x) { return P_ToStringMap[unsigned(x)]; }

/* @AUTOGEN-END@ */

namespace {
#include "CodeGenX64/isel_gen_patterns.h"
}  // namespace

const Pattern* FindMatchingPattern(Ins ins) {
  const uint64_t type_matcher = ExtractTypeMaskForPattern(ins);
  const OPC opc = InsOPC(ins);
  const uint16_t end = kPatternJumper[unsigned(opc) + 1];
  for (unsigned p = kPatternJumper[unsigned(opc)]; p < end; ++p) {
    const Pattern& pat = kPatterns[p];
    if (PatternMatchesTypeCurbs(pat, type_matcher) &&
        PatternMatchesOpCurbs(pat, ins))
      return &pat;
  }

  return nullptr;
}

int64_t ExtractReg(Reg reg) {
  ASSERT(reg.kind() == RefKind::REG, "not a reg " << unsigned(reg.kind()));
  CpuReg cpu_reg = RegCpuReg(reg);
  ASSERT(cpu_reg.kind() == RefKind::CPU_REG, "");
  return CpuRegNo(cpu_reg);
}

int64_t ExtractSpilledReg(Reg reg) {
  ASSERT(reg.kind() == RefKind::REG, "not a reg " << unsigned(reg.kind()));
  StackSlot slot = RegStackSlot(reg);
  ASSERT(slot.kind() == RefKind::STACK_SLOT, "");
  return StackSlotOffset(slot);
}

// TODO: should this return an uint32_t
int32_t GetStackOffset(Handle stk, Handle num) {
  ASSERT(stk.kind() == RefKind::STK, "");
  ASSERT(num.kind() == RefKind::CONST, "");
  return StkSlot(Stk(stk)) + ConstValueInt32(Const(num));
}

int64_t ExtractTmplArgOP(Ins ins, P arg, const EmitContext& ctx) {
  switch (arg) {
    case P::invalid:
      break;
    case P::reg01:
      ASSERT(InsOperand(ins, 0) == InsOperand(ins, 1), "");
      return ExtractReg(Reg(InsOperand(ins, 0)));
    case P::reg0:
    case P::reg1:
    case P::reg2:
    case P::reg3:
    case P::reg4:
      return ExtractReg(Reg(InsOperand(ins, +arg - +P::reg0)));
    case P::tmp_gpr:
      return +F::RAX;
    case P::tmp_flt:
      return +F::XMM0;
    case P::scratch_gpr: {
      CpuReg cpu_reg = ctx.scratch_cpu_reg;
      ASSERT(cpu_reg.kind() == RefKind::CPU_REG &&
                 CpuRegKind(cpu_reg) == +CPU_REG_KIND::GPR,
             "");
      return CpuRegNo(cpu_reg);
    }
    case P::num0:
    case P::num1:
    case P::num2:
    case P::num3:
    case P::num4: {
      Const num = Const(InsOperand(ins, +arg - +P::num0));
      return ConstValueInt64(num);
    }
    case P::spill01:
      ASSERT(InsOperand(ins, 0) == InsOperand(ins, 1), "");
    case P::spill0:
    case P::spill1:
    case P::spill2: {
      unsigned no = arg == P::spill01 ? 0 : +arg - +P::spill0;
      Reg reg = Reg(InsOperand(ins, no));
      ASSERT(reg.kind() == RefKind::REG, "");
      StackSlot slot = RegStackSlot(reg);
      ASSERT(slot.kind() == RefKind::STACK_SLOT, "");
      return StackSlotOffset(slot);
    }
    case P::stk1_offset2:
    case P::stk0_offset1:
    case P::stk1:
      ASSERT(false, "NYI");
      break;
    case P::bbl0:
    case P::bbl1:
    case P::bbl2:
    case P::fun0:
    case P::mem0_num1_prel:
    case P::mem1_num2_prel:
    case P::fun1_prel:
    case P::jtb1_prel:
      // relocs
      return 0;
  }
  ASSERT(false, "unsupported parmm " << +arg << " " << EnumToString(arg));
  return 0;
}

#if 0



}  // namespace



void EmitFunProlog(const EmitContext& ctx, std::vector<a64::Ins>* output) {
  RegBitVec gpr_regs(ctx.gpr_reg_mask);
  if (!gpr_regs.empty()) {
    while (!gpr_regs.empty()) {
      uint32_t r1 = gpr_regs.next_reg_no();
      if (gpr_regs.empty()) {
        output->push_back(
            MakeIns(a64::OPC::str_x_imm_pre, +FIXARG::WZR, -16, r1));
        break;
      }
      uint32_t r2 = gpr_regs.next_reg_no();
      output->push_back(
          MakeIns(a64::OPC::stp_x_imm_pre, +FIXARG::WZR, -16, r2, r1));
    }
  }

  RegBitVec flt_regs(ctx.flt_reg_mask);
  if (!flt_regs.empty()) {
    while (!flt_regs.empty()) {
      uint32_t r1 = flt_regs.next_reg_no();
      if (flt_regs.empty()) {
        output->push_back(
            MakeIns(a64::OPC::fstr_d_imm_pre, +FIXARG::WZR, -16, r1));
        break;
      }
      uint32_t r2 = flt_regs.next_reg_no();
      output->push_back(
          MakeIns(a64::OPC::fstp_d_imm_pre, +FIXARG::WZR, -16, r2, r1));
    }
  }
  uint32_t stk_size = ctx.stk_size;
  ASSERT((stk_size >> 24U) == 0, "stack too large");
  if ((stk_size & 0xfff000U) != 0) {
    output->push_back(MakeIns(a64::OPC::sub_x_imm, +FIXARG::WZR, +FIXARG::WZR,
                              stk_size & 0xfff000U));
  }

  if ((stk_size & 0xfffU) != 0) {
    output->push_back(MakeIns(a64::OPC::sub_x_imm, +FIXARG::WZR, +FIXARG::WZR,
                              stk_size & 0xfffU));
  }
}

void EmitFunEpilog(const EmitContext& ctx, std::vector<a64::Ins>* output) {
  const size_t start = output->size();
  // we will revert everything at the end
  output->push_back(MakeIns(a64::OPC::ret, +FIXARG::LR));

  RegBitVec gpr_regs(ctx.gpr_reg_mask);
  if (!gpr_regs.empty()) {
    while (!gpr_regs.empty()) {
      uint32_t r1 = gpr_regs.next_reg_no();
      if (gpr_regs.empty()) {
        output->push_back(
            MakeIns(a64::OPC::ldr_x_imm_post, r1, +FIXARG::WZR, 16));
        break;
      }
      uint32_t r2 = gpr_regs.next_reg_no();
      output->push_back(
          MakeIns(a64::OPC::ldp_x_imm_post, r2, r1, +FIXARG::WZR, 16));
    }
  }

  RegBitVec flt_regs(ctx.flt_reg_mask);
  if (!flt_regs.empty()) {
    while (!flt_regs.empty()) {
      uint32_t r1 = flt_regs.next_reg_no();
      if (flt_regs.empty()) {
        output->push_back(
            MakeIns(a64::OPC::fldr_d_imm_post, r1, +FIXARG::WZR, 16));
        break;
      }
      uint32_t r2 = flt_regs.next_reg_no();
      output->push_back(
          MakeIns(a64::OPC::fldp_d_imm_post, r2, r1, +FIXARG::WZR, 16));
    }
  }
  uint32_t stk_size = ctx.stk_size;
  ASSERT((stk_size >> 24U) == 0, "stack too large");
  if ((stk_size & 0xfffU) != 0) {
    output->push_back(MakeIns(a64::OPC::add_x_imm, +FIXARG::WZR, +FIXARG::WZR,
                              stk_size & 0xfffU));
  }

  if ((stk_size & 0xfff000U) != 0) {
    output->push_back(MakeIns(a64::OPC::add_x_imm, +FIXARG::WZR, +FIXARG::WZR,
                              stk_size & 0xfff000U));
  }
  std::reverse(output->begin() + start, output->end());
}
#endif

void MaybeHandleReloc(x64::Ins* cpuins, unsigned pos, Ins ins, P op) {
  ASSERT(!cpuins->has_reloc(), "");
  switch (op) {
    case P::bbl0:
    case P::bbl1:
    case P::bbl2: {
      const Bbl bbl = Bbl(InsOperand(ins, +op - +P::bbl0));
      cpuins->set_reloc(elf::RELOC_TYPE_X86_64::PC32, true, pos,
                        StrData(Name(bbl)));
      return;
    }
    case P::fun0: {
      const Fun fun = Fun(InsOperand(ins, 0));
      cpuins->set_reloc(elf::RELOC_TYPE_X86_64::PC32, false, pos,
                        StrData(Name(fun)));
      return;
    }
    case P::fun1_prel: {
      const Fun fun = Fun(InsOperand(ins, 1));
      ASSERT(FunKind(fun) != FUN_KIND::EXTERN, "undefined Fun" << Name(fun));
      cpuins->set_reloc(elf::RELOC_TYPE_X86_64::PC32, false, pos,
                        StrData(Name(fun)));
      return;
    }
    case P::mem1_num2_prel:
    case P::mem0_num1_prel: {
      const Mem mem = Mem(InsOperand(ins, +op - +P::mem0_num1_prel));
      ASSERT(MemKind(mem) != MEM_KIND::EXTERN, "undefined Fun" << Name(mem));
      const Const num = Const(InsOperand(ins, +op - +P::mem0_num1_prel + 1));
      cpuins->set_reloc(elf::RELOC_TYPE_X86_64::PC32, false, pos,
                        StrData(Name(mem)));
      cpuins->operands[pos] = ConstValueInt64(num);
      return;
    }
    case P::jtb1_prel: {
      const Jtb jtb = Jtb(InsOperand(ins, 1));
      cpuins->set_reloc(elf::RELOC_TYPE_X86_64::PC32, true, pos,
                        StrData(Name(jtb)));
      return;
    }
    default:
      return;
  }
}

x64::Ins MakeInsFromTmpl(const InsTmpl& tmpl, Ins ins, const EmitContext& ctx) {
  x64::Ins out;
  out.opcode = &x64::OpcodeTableEncodings[unsigned(tmpl.opcode)];
  // std::cout << "@@@@@@ OPCODE " << out.opcode->name << "\n";
  for (unsigned o = 0; o < out.opcode->num_fields; ++o) {
    if ((tmpl.template_mask & (1U << o)) == 0) {
      // fixed operand - we uses these verbatim
      out.operands[o] = tmpl.operands[o];
    } else {
      // std::cout << "@@Handle " << o << " " <<
      // a64::EnumToString(out.opcode->fields[o]) <<  "\n";
      // parameters require extra processing
      const P param = P(tmpl.operands[o]);
      out.operands[o] = ExtractTmplArgOP(ins, param, ctx);
      // Note: this may overwrite    out.operands[o]
      MaybeHandleReloc(&out, o, ins, param);
    }
  }
  return out;
}

}  // namespace cwerg::code_gen_x64
